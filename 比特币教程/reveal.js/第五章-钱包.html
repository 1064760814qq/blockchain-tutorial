<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section data-markdown>
                    # 第五章 钱包
                </section>

                <section data-markdown>
                    - “钱包”一词在比特币中有多重含义。
                    - 广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。
                    - 狭义上，即从程序员的角度来看，“钱包”是指用于存储和管理用户密钥的数据结构。
                    - 我们将深入介绍第二层含义，本章中钱包是私钥的容器，一般是通过结构化文件或简单数据库来实现。
                </section>

                <section data-markdown>
                    ## 钱包技术概述
                    - 一个常见误解是，比特币钱包里含有比特币。
                    - 事实上，钱包里只含有钥匙。
                    - “钱币”被记录在比特币网络的区块链中。
                    - 用户通过钱包中的密钥签名交易，从而来控制网络上的钱币。
                    - 在某种意义上，比特币钱包是密钥链。
                </section>

                <section data-markdown>
                    ## 继续
                    - 提示比特币钱包只含有密钥，而不是钱币。
                    - 每个用户有一个包含多个密钥的钱包。
                    - 钱包只包含私钥/公钥对的密钥链。
                    - 用户用密钥签名交易，从而证明他们拥有交易输出（他们的钱币）。
                    - 钱币以交易输出的形式存储在区块链中（通常记为vout或txout）。
                </section>

                <section data-markdown>
                    ## 继续
                    - 有两种主要类型的钱包，区别在于它们包含的多个密钥是否相互关联。
                    - 第一种类型是非确定性钱包（nondeterministic wallet），其中每个密钥都是从随机数独立生成的。
                    - 密钥彼此无关。这种钱包也被称为“Just a Bunch Of Keys（一堆密钥）”，简称JBOK钱包。
                </section>

                <section data-markdown>
                    ## 继续
                    - 第二种类型是确定性钱包（deterministic wallet），其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。
                    - 该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。
                    - 确定性钱包中使用了许多不同的密钥推导方法。
                    - 最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。
                </section>

                <section data-markdown>
                    ## 继续
                    - 确定性钱包由种子衍生创造。
                    - 为了便于使用，种子被编码为英文单词，也称为助记词。
                </section>

                <section data-markdown>
                    ## 非确定性（随机）钱包
                    - 在最早的一批比特币客户端中（Bitcoin Core，现在称作比特币核心客户端），钱包只是随机生成的私钥集合。
                    - 这种类型的钱包被称作零型非确定钱包。
                    - 举个例子，比特币核心客户端预先生成100个随机私钥，从最开始就生成足够多的私钥并且每个密钥只使用一次。
                </section>

                <section data-markdown>
                    ## 继续
                    - 这种钱包现在正在被确定性钱包替换，因为它们难以管理、备份以及导入。
                    - 随机密钥的缺点就是如果你生成很多私钥，你必须保存它们所有的副本。
                    - 这就意味着这个钱包必须被经常性地备份。
                </section>

                <section data-markdown>
                    ## 继续
                    - 每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。
                    - 这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。
                    - 地址重复使用将多个交易和地址关联在一起，这会减少隐私。
                </section>

                <section data-markdown>
                    ## 继续
                    - 当你想避免重复使用地址时，零型非确定性钱包并不是好的选择，因为你要创造过多的私钥并且要保存它们。
                    - 虽然比特币核心客户端包含零型钱包，但比特币的核心开发者并不鼓励大家使用。
                    - [示意图](./images/feiquedingxingqianbao.png)
                </section>

                <section data-markdown>
                    ## 确定性（种子）钱包 
                    - 确定性，或者“种子”钱包包含通过使用单项离散函数而可从公共的种子生成的私钥。
                    - 种子是随机生成的数字。这个数字也含有比如索引号码或者可生成私钥的“链码”。
                    - 在确定性钱包中，种子足够恢复所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。
                    - 并且种子也足够让钱包导入或者导出。这就很容易允许使用者的私钥在钱包之间轻松转移。 
                </section>

                <section data-markdown>
                    [确定性钱包示意图](./images/quedingxingqianbao.png)
                </section>

                <section data-markdown>
                    ## 分层确定性钱包（HD Wallets (BIP-32/BIP-44))
                    - 确定性钱包被开发成更容易从单个“种子”中生成许多密钥。
                    - 确定性钱包的最高级形式是通过BIP0032标准定义的HD钱包。
                    - HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。
                    - [树状结构](./images/shuzhuangjiegou.png)
                </section>

                <section data-markdown>
                    ## 继续
                    - 相比较随机（不确定性）密钥，HD钱包有两个主要的优势。
                    - 第一，树状结构可以被用来表达额外的组织含义。
                    - 比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。
                    - 不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。
                </section>

                <section data-markdown>
                    ## 继续
                    - HD钱包的第二个好处就是它可以允许使用者去建立一个公钥的序列而不需要访问相对应的私钥。
                    - 这允许HD钱包在不安全的服务器中使用或者在每笔交易中使用不同的公钥。
                    - 公钥不需要被预先加载或者提前产生，而在服务器中不需要可用来支付的私钥。
                </section>

                <section data-markdown>
                    ## 种子和助记词（BIP-39）
                    - HD钱包具有管理多个密钥和地址的强大机制。
                    - 由一系列英文单词生成种子是个标准化的方法，这样易于在钱包中转移、导出和导入，如果HD钱包与这种方法相结合，将会更加有用。
                    - 这些英文单词被称为助记词，标准由BIP-39定义。
                    - 今天，大多数比特币钱包（以及其他加密货币的钱包）使用此标准，并可以使用可互操作的助记词导入和导出种子进行备份和恢复。
                </section>

                <section data-markdown>
                    ## 对比
                    - 16进制表示的种子：0C1E24E5917779D297E14D45F14E1A1A
                    - 助记词表示的种子：army van defense carry jealous true garbage claim echo media make crunch
                </section>

                <section data-markdown>
                    ## 钱包最佳实践
                    - 助记码，基于BIP-39
                    - HD钱包，基于BIP-32
                    - 多用途HD钱包结构，基于BIP-43
                    - 多币种和多帐户钱包，基于BIP-44
                    - 用户可以导出在其中一个钱包上生成的助记符，并将其导入另一个钱包，实现恢复所有交易，密钥和地址。
                </section>

                <section data-markdown>
                    ## 使用比特币钱包
                    - 首次使用比特币钱包时，设备从内置的硬件随机数生成器生成助记词和种子。
                    - 在这个初始化阶段，钱包在屏幕上按顺序逐个显示单词。
                    - 通过写下这个助记符，我们可以创建了一个备份，可以恢复。
                </section>

                <section data-markdown>
                    ## 使用比特币钱包
                    - 新的钱包，助记词可以用于恢复。
                    - 请注意，单词序列很重要，因此，记忆纸备份需要对每个单词都有空格。
                    - 必须仔细记录每个单词的编号，以保持正确的顺序。
                    - [助记词](./images/zhujici.png)
                </section>

                <section data-markdown>
                    ## 钱包技术细节
                </section>

                <section data-markdown>
                    ## 助记码词汇（BIP-39）
                    - 助记码词汇是英文单词序列代表（编码）用作种子对应所确定性钱包的随机数。
                    - 单词的序列足以重新创建种子，并且从种子那里重新创造钱包以及所有私钥。
                    - 在首次创建钱包时，带有助记码的，运行确定性钱包的钱包的应用程序将会向使用者展示一个12至24个词的顺序。
                </section>

                <section data-markdown>
                    ## 继续
                    - 单词的顺序就是钱包的备份。
                    - 它也可以被用来恢复以及重新创造应用程序相同或者兼容的钱包的密钥。
                    - 助记码词汇可以让使用者复制钱包更容易一些，因为相比较随机数字顺序来说，它们更容易地被阅读和正确抄写。
                </section>

                <section data-markdown>
                    ## 创建助记词
                    - 1、创建一个128到256位的随机序列（熵）。
                    - 2、提出SHA256哈希前几位（熵长/32），就可以创造一个随机序列的校验和。
                    - 3、将校验和添加到随机序列的末尾。
                </section>

                <section data-markdown>
                    ## 创建助记词
                    - 4、将序列划分为包含11位的不同部分。
                    - 5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。
                    - 6、生成的有顺序的单词组就是助记码。
                </section>

                <section data-markdown>
                    [示意图](./images/chuangjianzhujici.png)
                </section>

                <section data-markdown>
                    ## 从助记词生成种子
                    - 助记词表示长度为128至256位的熵。
                    - 通过使用密钥延伸函数PBKDF2，熵被用于导出较长的（512位）种子。
                    - 将所得的种子用于构建确定性钱包并得到其密钥。
                </section>

                <section data-markdown>
                    ## 从助记词生成种子
                    - 密钥延伸函数有两个参数：助记词和盐。
                    - 其中盐的目的是增加构建能够进行暴力攻击的查找表的困难度。
                    - 在BIP-39标准中，盐具有另一目的，它允许引入密码短语（passphrase）。
                </section>

                <section data-markdown>
                    ## 创建助记词之后的7-9步是：
                    - 7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。
                    - 8、PBKDF2密钥延伸函数的第二个参数是盐。由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。
                    - 9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。这个512位的值就是种子。
                </section>

                <section data-markdown>
                    - [熵数据的大小和助记词的长度之间的关系](./images/zhujicichangdu.png)
                    - [从助记词如何生成种子](./images/shengchengzhongzi.png)
                    - 密钥延伸函数，使用2048次哈希是一种非常有效的保护，可以防止对助记词或密码短语的暴力攻击。
                    - 它使得攻击尝试非常昂贵（从计算的角度），需要尝试超过几千个密码和助记符组合，而这样可能产生的种子的数量是巨大的（2^512）。
                </section>

                <section data-markdown>
                    ## 一些助记码的例子和它所生成的种子
                    - [例子1](./images/lizi1.png)
                    - [例子2](./images/lizi2.png)
                    - [例子3](./images/lizi3.png)
                    - ![生成助记词的网站](https://iancoleman.io/bip39)
                </section>

                <section data-markdown>
                    ## 从种子中创造HD钱包
                    - HD钱包从单个根种子（root seed）中创建，为128到256位的随机数。
                    - 最常见的是，这个种子是从助记符产生的。
                    - HD钱包的所有的确定性都衍生自这个根种子。
                    - 任何兼容HD钱包的根种子也可重新创造整个HD钱包。
                    - 所以简单的转移HD钱包的根种子就让HD钱包中所包含的成千上百万的密钥被复制，储存导出以及导入。
                </section>

                <section data-markdown>
                    [创建主密钥以及HD钱包的主链代码的过程](./images/hd.png)
                </section>

                <section data-markdown>
                    ## 继续
                    - 根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造主私钥(m)（master private key(m)）和主链代码（a master chain code）的哈希。
                    - 主私钥（m）之后可以通过使用我们在本章先前看到的那个普通椭圆曲线m * G过程生来成相对应的主公钥（M）。
                    - 链代码用于从母密钥中创造子密钥的那个函数中引入熵。
                </section>

                <section data-markdown>
                    ## 私有子密钥的衍生
                    - 分层确定性钱包使用CKD（child key derivation)函数去从母密钥衍生出子密钥。
                    - 子密钥衍生函数是基于单项哈希函数。这个函数结合了：
                        - 一个母私钥或者公钥（ECDSA未压缩密钥）
                        - 一个叫做链码（256 bits）的种子
                        - 一个索引号（32 bits）
                </section>

                <section data-markdown>
                    ## 继续
                    - 链码是用来给这个过程引入确定性随机数据的，使得索引不能充分衍生其他的子密钥。
                    - 因此，有了子密钥并不能让它发现自己的姊妹密钥，除非你已经有了链码。
                    - 最初的链码种子（在密码树的根部）是用随机数据构成的，随后链码从各自的母链码中衍生出来。
                    - （母私钥，链码，索引）相结合并散列可以生成子密钥。
                </section>

                <section data-markdown>
                    ## 继续
                    - 母公钥——链码——以及索引号合并在一起并且用HMAC-SHA512函数散列之后可以产生512位的散列。
                    - 所得的散列可被拆分为两部分。
                    - 散列右半部分的256位产出可以给子链当链码。
                    - 左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。
                    - 在下图中，我们看到这个说明——索引集被设为0去生产母密钥的第0个子密钥（第一个通过索引）。
                </section>

                <section data-markdown>
                    [索引集被设为0去生产母密钥的第0个子密钥（第一个通过索引）](./images/zimiyao.png)
                </section>

                <section data-markdown>
                    ## 继续
                    - 改变索引可以让我们延长母密钥以及创造序列中的其他子密钥。
                    - 比如子0，子1，子2等等。
                    - 每一个母密钥可以有2,147,483,647 (2^31) 个子密钥。
                    - 2^31是整个2^32范围可用的一半，因为另一半是为特定类型的推导而保留的。
                    - 向密码树下一层重复这个过程，每个子密钥可以依次成为母密钥继续创造它自己的子密钥，直到无限代。
                </section>

                <section data-markdown>
                    ## 使用衍生的子密钥
                    - 子私钥不能从非确定性（随机）密钥中被区分出来。
                    - 因为衍生函数是单向的，所以子密钥不能被用来发现他们的母密钥。
                    - 子密钥也不能用来发现他们的相同层级的姊妹密钥。
                </section>

                <section data-markdown>
                    ## 使用衍生的子密钥
                    - 如果你有第n个子密钥，你不能发现它前面的（第n－1）或者后面的子密钥（n＋1）或者在同一顺序中的其他子密钥。
                    - 只有母密钥以及链码才能得到所有的子密钥。
                    - 没有子链码的话，子密钥也不能用来衍生出任何孙密钥。
                    - 你需要同时有子密钥以及对应的链码才能创建一个新的分支来衍生出孙密钥。
                </section>

                <section data-markdown>
                    ## 使用衍生的子密钥
                    - 那子私钥自己可被用做什么呢？它可以用来做公钥和比特币地址。之后它就可以被用在那个地址来签署交易和支付任何东西。
                    - 子私钥、对应的公钥以及比特币地址都不能从随机创造的密钥和地址中被区分出来。
                    - 事实是它们所在的序列，在创造他们的HD钱包函数之外是不可见的。
                    - 一旦被创造出来，它们就和“正常”密钥一样运行了。
                </section>

                <section data-markdown>
                    ## 扩展密钥
                    - 密钥衍生函数可以被用来创造密钥树上任何层级的子密钥。
                    - 这只需要三个输入量：一个密钥，一个链码以及想要的子密钥的索引。
                    - 密钥以及链码这两个重要的部分结合之后，就叫做扩展密钥（extended key）。
                    - 因为这种密钥可以用来衍生子密钥。
                </section>

                <section data-markdown>
                    ## 继续
                    - 扩展密钥可以简单地被储存并且表示为简单的将256位密钥与256位链码所并联的512位序列。
                    - 有两种扩展密钥。扩展的私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公钥）。
                    - 公钥以及链码组成扩展公钥，它可以用来扩展子公钥。
                </section>

                <section data-markdown>
                    ## 继续
                    - 想象一个扩展密钥作为HD钱包中密钥树结构的一个分支的根。
                    - 你可以衍生出这个分支的剩下所有部分。
                    - 扩展私钥可以创建一个完整的分支，而扩展公钥只能够创造一个公钥的分支。
                </section>

                <section data-markdown>
                    ## 继续
                    - 一个扩展密钥包括一个私钥（或者公钥）以及一个链码。
                    - 一个扩展密钥可以创造出子密钥并且能创造出密钥树结构中的整个分支。
                    - 分享扩展密钥就可以访问整个分支。
                </section>

                <section data-markdown>
                    ## 继续
                    - 扩展密钥通过Base58Check来编码，从而能轻易地在不同的BIP-32兼容钱包之间导入导出。
                    - 扩展密钥编码用的Base58Check使用特殊的版本号，这导致在Base58编码字符中，出现前缀“xprv”和“xpub”。
                    - 这种前缀可以让编码更易被识别。因为扩展密钥是512或者513位，所以它比我们之前所看到的Base58Check编码串更长一些。
                </section>

                <section data-markdown>
                    - 以下面的扩展私钥为例，其使用的是Base58Check编码：
                    - `xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c`
                    - 这是上面扩展私钥对应的扩展公钥，同样使用Base58Check编码：
                    - `xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9`
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/search/search.js', async: true },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>