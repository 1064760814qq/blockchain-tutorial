<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>第六章 交易</h1>
                </section>
                
                <section data-markdown>
                    ## 简介
                    - 比特币交易是比特币系统中最重要的部分。
                    - 根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿（比特币区块链）。
                    - 比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。
                    - 比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。
                </section>

                <section data-markdown>
                    ## 交易细节
                    [示意图](./images/jiaoyixijie.png)
                </section>

                <section data-markdown>
                    ## 交易 - 幕后细节
                    - 在幕后，实际的交易看起来与典型的区块浏览器提供的交易非常不同。
                    - 事实上，我们在各种比特币应用程序用户界面中看到的大多数高级结构实际上并不存在于比特币系统中。
                    - 我们可以使用Bitcoin Core的命令行界面（getrawtransaction和decodeawtransaction）来检索上面图中那笔“原始”交易，对其进行解码，并查看它包含的内容。 
                    - 交易被解码后是这个样子：
                </section>

                <section data-markdown>
                    ## 交易解码以后
                    ```
                    {
                        "version": 1,
                        "locktime": 0,
                        "vin": [
                          {
                            "txid":"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
                            "vout": 0,
                            "scriptSig": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
                            "sequence": 4294967295
                          }
                       ],
                        "vout": [
                          {
                            "value": 0.01500000,
                            "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
                          },
                          {
                            "value": 0.08450000,
                            "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
                          }
                        ]
                      }
                      ```
                </section>

                <section data-markdown>
                    ## 继续
                    - 您可能会注意到这笔交易似乎少了些什么东西，比如：发送者的地址在哪里？接收者的地址在哪里？
                    - 发送者发送的“0.1”个币的输入在哪里？
                    - 在比特币里，没有具体的货币，没有发送者，没有接收者，没有余额，没有帐户，没有地址。
                    - 为了使用者的便利，以及使事情更容易理解，所有这些都构建在更高层次上。你可能还会注意到很多奇怪和难以辨认的字段以及十六进制字符串。
                </section>

                <section data-markdown>
                    ## 交易的输入输出
                    - 比特币交易中的基础构建单元是交易输出。
                    - 交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络识别为有效。
                    - 比特币完整节点跟踪所有可找到的和可使用的输出，称为“未花费的交易输出”（unspent transaction outputs），即UTXO。
                    - 所有UTXO的集合被称为UTXO集，目前有数百万个UTXO。
                    - 当新的UTXO被创建，UTXO集就会变大，当UTXO被消耗时，UTXO集会随着缩小。每一个交易都代表UTXO集的变化（状态转换）。
                </section>

                <section data-markdown>
                    ## 继续
                    - 当我们说用户的钱包已经“收到”比特币时，我们的意思是，钱包已经检测到了可用的UTXO。
                    - 通过钱包所控制的密钥，我们可以把这些UTXO花出去。
                    - 因此，用户的比特币“余额”是指用户钱包中可用的UTXO总和，而他们可能分散在数百个交易和区块中。
                </section>

                <section data-markdown>
                    ## 继续
                    - “一个用户的比特币余额”，这个概念是比特币钱包应用创建的派生之物。
                    - 比特币钱包通过扫描区块链并聚集所有属于该用户的UTXO来计算该用户的余额。
                    - 大多数钱包维护一个数据库或使用数据库服务来存储所有UTXO的快速参考集，这些UTXO由用户所有的密钥来控制花费行为。
                </section>

                <section data-markdown>
                    ## 继续
                    - 一个UTXO可以是1“聪”（satoshi）的任意倍数（整数倍）。
                    - 就像美元可以被分割成表示两位小数的“分”一样，比特币可以被分割成八位小数的“聪”。
                    - 尽管UTXO可以是任意值，但一旦被创造出来，即不可分割。
                    - 这是UTXO值得被强调的一个重要特性：UTXO是面值为“聪”的离散（不连续）且不可分割的价值单元，一个UTXO只能在一次交易中作为一个整体被消耗。
                </section>

                <section data-markdown>
                    ## 继续
                    - 如果一个UTXO比一笔交易所需量大，它仍会被当作一个整体而消耗掉，但同时会在交易中生成零头。
                    - 例如，你有一个价值20比特币的UTXO并且想支付1比特币，那么你的交易必须消耗掉整个20比特币的UTXO，并产生两个输出：一个支付了1比特币给接收人，另一个支付了19比特币的找零到你的钱包。
                    - 这样的话，由于UTXO（或交易输出）的不可分割特性，大部分比特币交易都会产生找零。
                </section>

                <section data-markdown>
                    ## 继续
                    - 想象一下，一位顾客要买1.5元的饮料。
                    - 她掏出钱包并试图从所有硬币和钞票中找出一种组合来凑齐她要支付的1.5元。
                    - 如果可能的话，她会选刚刚好的零钱（比如一张1元纸币和5个一毛硬币）或者是小面额的组合（比如3个五毛硬币）。
                    - 如果都不行的话，她会用一张大面额的钞票，比如5元纸币。如果她把5元给了商店老板，她会得到3.5元的找零，并把找零放回她的钱包以供未来的交易使用。
                </section>

                <section data-markdown>
                    ## 继续
                    - 类似的，一笔比特币交易可以是任意金额，但必须从用户可用的UTXO中创建出来。
                    - 用户不能再把UTXO进一步细分，就像不能把一元纸币撕开而继续当货币使用一样。
                    - 用户的钱包应用通常会从用户可用的UTXO中选取多个来拼凑出一个大于或等于一笔交易所需的比特币量。
                </section>

                <section data-markdown>
                    ## 继续
                    - 就像现实生活中一样，比特币应用可以使用一些策略来满足付款需求：
                    - 组合若干小额UTXO，并算出准确的找零；或者使用一个比交易额大的UTXO然后进行找零。
                    - 所有这些复杂的、由可花费UTXO组成的集合，都是由用户的钱包自动完成，并不为用户所见。
                    - 只有当你以编程方式用UTXO来构建原始交易时，这些才与你有关。
                </section>

                <section data-markdown>
                    ## 继续
                    - 一笔交易会消耗先前的已被记录（存在）的UTXO，并创建新的UTXO以备未来的交易消耗。
                    - 通过这种方式，一定数量的比特币价值在不同所有者之间转移，并在交易链中消耗和创建UTXO。
                    - 一笔比特币交易通过使用所有者的签名来解锁UTXO，并通过使用新的所有者的比特币地址来锁定并创建UTXO。
                </section>

                <section data-markdown>
                    ## 继续
                    - 从交易的输出与输入链角度来看，有一个例外，即存在一种被称为“币基交易”（Coinbase Transaction）的特殊交易，
                    - 它是每个区块中的第一笔交易，这种交易存在的原因是作为对挖矿的奖励，创造出全新的可花费比特币用来支付给“赢家”矿工。
                    - 这也就是为什么比特币可以在挖矿过程中被创造出来，我们将在“挖矿”这一章进行详述。
                </section>

                <section data-markdown>
                    ## 继续
                    - 输入和输出，哪一个是先产生的呢？先有鸡还是先有蛋呢？
                    - 严格来讲，先产生输出，因为可以创造新比特币的“币基交易”没有输入，但它可以无中生有地产生输出。
                </section>

                <section data-markdown>
                    ## 交易输出
                    - 每一笔比特币交易都会创造输出，并被比特币账簿记录下来。
                    - 几乎所有的输出都能创造一定数量的可用于支付的比特币，也就是UTXO。
                    - 这些UTXO被整个网络识别，所有者可在未来的交易中使用它们。
                </section>

                <section data-markdown>
                    ## 继续
                    - UTXO在UTXO集（UTXOset）中被每一个全节点比特币客户端追踪。
                    - 新的交易从UTXO集中消耗（花费）一个或多个输出。
                </section>

                <section data-markdown>
                    ## 继续
                    - 交易输出包含两部分：
                        - 一定量的比特币，面值为“聪”（satoshis），是最小的比特币单位；
                        - 确定花费输出所需条件的加密难题（cryptographic puzzle）
                    - 这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。
                </section>

                <section data-markdown>
                    ## 继续
                    - 在JSON编码中，输出位于名为vout的数组（列表）中：
                    ```
                    "vout": [
                        {
                          "value": 0.01500000,
                          "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
                        },
                        {
                          "value": 0.08450000,
                          "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
                        }
                    ]
                    ```
                </section>

                <section data-markdown>
                    ## 继续
                    - 交易包含两个输出。每个输出都由一个值和一个加密难题来定义。
                    - 在Bitcoin Core显示的编码中，该值显示以bitcoin为单位，但在交易本身中，它被记录为以satoshis为单位的整数。
                    - 每个输出的第二部分是设定支出条件的加密难题。
                    - Bitcoin Core将其显示为scriptPubKey，并向我们展示了一个可读的脚本表示。
                </section>

                <section data-markdown>
                    ## 交易序列化 - 输出
                    - 当交易通过网络传输或在应用程序之间交换时，它们被序列化。
                    - 序列化是将内部的数据结构表示转换为可以一次发送一个字节的格式（也称为字节流）的过程。
                    - 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。
                    - 交易输出的序列化格式如下表所示：
                    - [示意图](./images/jiaoyishuchu.png)
                </section>

                <section data-markdown>
                    ## 继续
                    - 大多数比特币函数库和架构不会在内部将交易存储为字节流，因为每次需要访问单个字段时，都需要复杂的解析。
                    - 为了方便和可读性，比特币函数库将交易内部存储在数据结构（通常是面向对象的结构）中。
                </section>

                <section data-markdown>
                    ## 继续
                    - 从交易的字节流表示转换为函数库的内部数据结构表示的过程称为反序列化或交易解析。
                    - 转换回字节流以通过网络传输、哈希化（hashing）或存储在磁盘上的过程称为序列化。
                    - 大多数比特币函数库具有用于交易序列化和反序列化的内置函数。
                </section>

                <section data-markdown>
                    ## 继续
                    - 看看是否可以从序列化的十六进制形式手动解码的一笔交易中，找到我们以前看到的一些元素。包含两个输出的部分在下面中已加粗显示：
                    - [示意图](./images/jiacuxianshi.png)
                </section>

                <section data-markdown>
                    ## 提示
                    - 加粗显示的部分有两个输出，每个都如本节之前所述进行了序列化。
                    - 0.015比特币的价值是1,500,000 satoshis。 这是十六进制的16 e3 60。
                    - 在串行化交易中，值16 e3 60以小端（最低有效字节优先）字节顺序进行编码，所以它看起来像60 e3 16。
                    - scriptPubKey的长度为25个字节，以十六进制显示为19个字节。
                </section>

                <section data-markdown>
                    ## 交易输入
                    - 交易输入将UTXO（通过引用）标记为将被消费，并通过解锁脚本提供所有权证明。
                    - 要构建一个交易，一个钱包从它控制的UTXO中选择足够的价值来执行被请求的付款。
                    - 有时一个UTXO就足够，其他时候不止一个。
                    - 对于将用于进行此付款的每个UTXO，钱包将创建一个指向UTXO的输入，并使用解锁脚本解锁它。
                </section>

                <section data-markdown>
                    ## 继续
                    - 让我们更详细地看一下输入的组件。
                    - 输入的第一部分是一个指向UTXO的指针，通过指向UTXO被记录在区块链中所在的交易的哈希值和序列号来实现。
                    - 第二部分是解锁脚本，钱包构建它用以满足设定在UTXO中的支出条件。
                    - 大多数情况下，解锁脚本是一个证明比特币所有权的数字签名和公钥，但是并不是所有的解锁脚本都包含签名。
                    - 第三部分是序列号，稍后再讨论。
                </section>

                <section data-markdown>
                    ## 继续
                    - 考虑我们在之前交易幕后章节提到的例子。
                    - 交易输入是一个名为 vin 的数组（列表）：
                    ```
                    "vin": [
                        {
                          "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
                          "vout": 0,
                          "scriptSig": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
                          "sequence": 4294967295
                        }
                    ]
                    ```
                </section>

                <section data-markdown>
                    ## 继续
                    - 列表中只有一个输入（因为一个UTXO包含足够的值来完成此付款）。输入包含四个元素：
                        - 一个交易ID，引用包含正在使用的UTXO的交易
                        - 一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）
                        - 一个 scriptSig（解锁脚本），满足放置在UTXO上的条件，解锁它用于支出
                        - 一个序列号（稍后讨论）
                </section>

                <section data-markdown>
                    ## 继续
                    - 在这一笔交易中，输入指向的交易ID是：`7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18`
                    - 输出索引是0（即由该交易创建的第一个UTXO）。
                    - 解锁脚本由本人的钱包构建，首先检索引用的UTXO，检查其锁定脚本，然后使用它来构建所需的解锁脚本以满足此要求。
                </section>

                <section data-markdown>
                    ## 继续
                    - 仅仅看这个输入，你可能已经注意到，除了对包含它引用的交易之外，我们无从了解这个UTXO的任何内容。
                    - 我们不知道它的价值（多少satoshi金额），我们不知道设置支出条件的锁定脚本。
                    - 要找到这些信息，我们必须通过检索整个交易来检索被引用的UTXO。
                    - 请注意，由于输入的值未明确说明，因此我们还必须使用被引用的UTXO来计算在此交易中支付的费用（参见后面交易费用）。
                </section>

                <section data-markdown>
                    ## 继续
                    - 不仅仅是本人的钱包需要检索输入中引用的UTXO。
                    - 一旦将该交易广播到网络，每个验证节点也将需要检索交易输入中引用的UTXO，以验证该交易。
                </section>

                <section data-markdown>
                    ## 继续
                    - 因为缺乏语境，交易本身似乎不完整。
                    - 他们在输入中引用UTXO，但是没有检索到UTXO，我们无法知道输入的值或其锁定条件。
                    - 当编写比特币软件时，无论何时解码交易以验证它或计算费用或检查解锁脚本，代码首先必须从块链中检索引用的UTXO，
                </section>

                <section data-markdown>
                    ## 继续
                    - 以构建隐含但不存在于输入的UTXO引用中的语境。
                    - 例如，要计算支付总额的交易费，我们必须知道输入和输出值的总和。
                    - 但是，如果不检索输入中引用的UTXO，则不知道它们的值。因此，在单个交易中计算交易费用的简单操作，实际上涉及多个交易的多个步骤和数据。
                </section>

                <section data-markdown>
                    ## 继续
                    - 我们可以使用与Bitcoin core相同的命令，
                    - 就像我们在检索这笔交易（getrawtransaction和decodeawtransaction）时一样。
                    - 因此，我们可以得到在前面的输入中引用的UTXO，并查看：
                    - 输入中引用的来自以前的交易中的UTXO：
                    ```
                    "vout": [
                        {
                          "value": 0.10000000,
                          "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
                        }
                    ]
                    ```
                </section>

                <section data-markdown>
                    ## 继续
                    - 我们看到这个UTXO的值为0.1BTC，并且它有一个包含“OP_DUP OP_HASH160 ...”的锁定脚本（scriptPubKey）。
                    - 为了充分了解这笔交易，我们必须检索引用以前的交易作为输入。
                    - 检索以前的交易和未花费的交易输出的函数是非常普遍的，并且存在于几乎每个比特币函数库和API中。
                </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
