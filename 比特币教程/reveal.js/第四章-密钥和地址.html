<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>第四章 密钥和地址</h1>
				</section>

				<section data-markdown>
                    ## 简介
                    - 比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的。
                    - 数字密钥实际上并不存储在网络中，而是由用户生成之后，存储在钱包或数据库中。
                    - 存储在用户钱包中的数字密钥完全独立于比特币协议，可由用户的钱包软件生成并管理，而无需参照区块链或访问网络。
                    - 密钥实现了比特币的许多有趣特性，包括去中心化信任和控制、所有权认证和基于密码学证明的安全模型。
				</section>

				<section data-markdown>
                    ## 简介
                    - 大多数比特币交易都需要一个有效的签名才会被存储在区块链。
                    - 只有有效的密钥才能产生有效的数字签名，因此拥有密钥副本就拥有了对该帐户的比特币的控制权。
                    - 用于支出资金的数字签名也称为见证（witness）。
                    - 比特币交易中的见证数据证明了所花费的比特币真正归谁所有。
				</section>

				<section data-markdown>
                    ## 简介
                    - 密钥是成对出现的，由一个私钥和一个公钥所组成。(非对称加密)
                    - 公钥就像银行的帐号，而私钥就像控制账户的PIN码或支票的签名。
                    - 比特币的用户很少会直接看到数字密钥。一般情况下，它们被存储在钱包文件内，由比特币钱包软件进行管理。
				</section>
				
				<section data-markdown>
                    ## 简介
                    - 在比特币交易的支付环节，收件人的公钥是通过其数字指纹代表的，称为比特币地址，就像支票上的支付对象的名字（即“收款方”）。
                    - 一般情况下，比特币地址由一个公钥生成并对应于这个公钥。
                    - 并非所有比特币地址都是公钥；他们也可以代表其他支付对象，譬如脚本。
                </section>

                <section data-markdown>
                    ## 简介
                    - 比特币地址把收款方抽象起来，使得交易的目的地更灵活。
                    - 就像支票一样：这个支付工具可支付到个人账户、公司账户，进行账单支付或现金支付。
                    - 用户的比特币地址可以公开出来。
				</section>

				<section data-markdown>
                    ## 公钥加密和加密货币
                    - 公钥加密发明于20世纪70年代。它是计算机和信息安全的数学基础。
                    - 自从公钥加密被发明之后，一些合适的数学函数被发现，譬如：素数幂和椭圆曲线乘法。
                    - 这些数学函数都是不可逆的，就是说很容易向一个方向计算，但不可以向相反方向倒推。
                    - 基于这些数学函数的密码学，使得生成数字密钥和不可伪造的数字签名成为可能。
                    - 比特币正是使用椭圆曲线乘法作为其公钥加密的基础。
                </section>
                
                <section data-markdown>
                    ## 公钥加密和加密货币
                    - 在比特币系统中，我们用公钥加密创建一个密钥对，用于控制比特币的获取。
                    - 密钥对包括一个私钥，和由其衍生出的唯一的公钥。
                    - 公钥用于接收比特币，而私钥用于比特币支付时的交易签名。
                </section>

				<section data-markdown>
                    ## 公钥加密和加密货币
                    - 公钥和私钥之间的数学关系，使得私钥可用于生成特定消息的签名。此签名可以在不泄露私钥的同时对公钥进行验证。
                    - 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从同一个私钥生成）。
                    - 比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。
				</section>

				<section data-markdown>
                    ## 公钥加密和加密货币
                    - 大多数比特币钱包工具为了方便会将私钥和公钥以密钥对的形式存储在一起。然而，公钥可以由私钥计算得到，所以只存储私钥也是可以的。
				</section>

				<section data-markdown>
					## 私钥和公钥
					- 一个比特币钱包中包含一系列的密钥对，每个密钥对包括一个私钥和一个公钥。
					- 私钥（k）是一个数字，通常是随机选出的。
					- 有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。
					- 有了公钥（K），我们就可以使用一个单向加密哈希函数生成比特币地址（A）。
				</section>

				<section data-markdown>
					[示意图](./images/key.png)
				</section>

				<section data-markdown>
					## 为什么使用非对称加密（公钥/私钥）？
					- 它不是用于“加密”交易。相反，非对称密码学的具有生成数字签名的能力。
					- 可以将私钥应用于交易的数字指纹以产生数字签名。该签名只能由知晓私钥的人生成。
					- 但是，访问公钥和交易指纹的任何人都可以使用它们来验证签名。
					- 这种非对称密码学的适用性使得任何人都可以验证每笔交易的每个签名，同时确保只有私钥的所有者可以产生有效的签名。
				</section>

				<section data-markdown>
					## 私钥
					- 私钥就是一个随机选出的数字而已。
					- 一个比特币地址中的所有资金的控制取决于相应私钥的所有权和控制权。
					- 在比特币交易中，私钥用于生成支付比特币所必需的签名以证明对资金的所有权。
					- 私钥必须始终保持机密，因为一旦被泄露给第三方，相当于该私钥保护之下的比特币也拱手相让了。
					- 私钥还必须进行备份，以防意外丢失，因为私钥一旦丢失就难以复原，其所保护的比特币也将永远丢失。
				</section>

				<section data-markdown>
					## 私钥
					- 比特币私钥只是一个数字。
					- 你可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币256次，用纸和笔记录正反面并转换为0和1，随机得到的256位二进制数字可作为比特币钱包的私钥。
					- 该私钥可进一步生成公钥。
				</section>

				<section data-markdown>
					## 从一个随机数生成私钥
					- 生成密钥的第一步也是最重要的一步，是要找到足够安全的熵源，即随机性来源。
					- 生成一个比特币私钥在本质上与“在1到2^256之间选一个数字”无异。
					- 只要选取的结果是不可预测或不可重复的，那么选取数字的具体方法并不重要。
					- 比特币软件使用操作系统底层的随机数生成器来产生256位的熵（随机性）。
					- 通常情况下，操作系统随机数生成器由人工的随机源进行初始化，这就是为什么也可能需要不停晃动鼠标几秒钟。
				</section>

				<section data-markdown>
					## 从一个随机数生成私钥
					- 更准确地说，私钥可以是1和n-1之间的任何数字，其中n是一个常数（n=1.158 * 10^77，略小于2^256），并被定义为由比特币所使用的椭圆曲线的阶。
					- 要生成这样的一个私钥，我们随机选择一个256位的数字，并检查它是否小于n-1。
					- 从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字。
					- 如果运算结果小于n-1，我们就有了一个合适的私钥。否则，我们就用另一个随机数再重复一次。
				</section>

				<section data-markdown>
					## 警告
					- 不要自己写代码或使用你的编程语言提供的简易随机数生成器来获得一个随机数。
					- 使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。
					- 使用随机数发生器的程序库时，需仔细研读其文档，以确保它是加密安全的。正确实施CSPRNG是密钥安全性的关键所在。
				</section>

				<section data-markdown>
					## 示例
					- 以下是一个随机生成的私钥（k），以十六进制格式表示（256位的二进制数，以64位十六进制数显示，每个十六进制数占4位）：
					- `1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD`
					- 比特币私钥空间的大小是2^256，这是一个非常大的数字。用十进制表示的话，大约是10^77，而宇宙被估计只含有10^80个原子。
				</section>

				<section data-markdown>
					## 使用比特币客户端生成私钥
					- 要使用比特币核心客户端生成一个新的密钥，可使用getnewaddress命令。
					- 出于安全考虑，命令运行后只显示生成的公钥，而不显示私钥。
					- 如果要bitcoind显示私钥，可以使用dumpprivkey命令。dumpprivkey命令会把私钥以Base58校验和编码格式显示，这种私钥格式被称为钱包导入格式。
				</section>

				<section data-markdown>
					## 示例
					```
					$ bitcoin-cli getnewaddress
					1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
					$ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
					KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
					```
				</section>

				<section data-markdown>
					## 解释
					- dumpprivkey命令打开钱包提取由getnewaddress命令生成的私钥。
					- dumpprivkey命令无法从公钥得到对应的私钥，因为这是不可能的。这个命令只是显示钱包中已有也就是由getnewaddress命令生成的私钥。
				</section>

				<section data-markdown>
					## 公钥
					- 通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G。
					- 其中k是私钥，G是被称为生成点的常数点，而K是所得公钥。
					- 其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索。
				</section>

				<section data-markdown>
					## 公钥
					- 椭圆曲线乘法是密码学家称之为“陷阱门”功能的一种函数：在一个方向（乘法）很容易做，而不可能在相反的方向（除法）做。
					- 私钥的所有者可以容易地创建公钥，然后与世界共享，因为没有人可以从公钥中反转函数并计算出私钥。
					- 这个数学技巧成为证明比特币资金所有权的不可伪造和安全的数字签名的基础。
				</section>

				<section data-markdown>
					## 椭圆曲线密码学
					- 椭圆曲线加密法是一种基于离散对数问题的非对称加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。
					- 下图是一个椭圆曲线的示例，类似于比特币所用的曲线。
					[椭圆曲线加密算法](./images/tuoyuan.png)
				</section>

				<section data-markdown>
					## 椭圆曲线密码学
					- 比特币使用了secp256k1标准所定义的一种特殊的椭圆曲线和一系列数学常数。
					- 该标准由美国国家标准与技术研究院（NIST）设立。secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线：
					[椭圆曲线公式](./images/gongshi.png)
				</section>
				
				<section data-markdown>
					## 椭圆曲线加密算法
					- 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1，这是个非常大的素数。
					- 因为这条曲线被定义在一个素数阶的有限域内，而不是定义在实数范围，它的函数图像看起来像分散在两个维度上的散落的点，因此很难可视化。
					- 不过，其中的数学原理与实数范围的椭圆曲线相似。作为一个例子，下图显示了在一个小了很多的素数阶17的有限域内的椭圆曲线，其形式为网格上的一系列散点。
					- 而secp256k1的比特币椭圆曲线可以被想象成一个极大的网格上一系列更为复杂的散点。
				</section>

				<section data-markdown>
					## 散点图
					[散点图](./images/sandian.png)
				</section>

				<section data-markdown>
					## 举例子
					- 这是secp256k1曲线上的点P，其坐标为(x，y)。可以使用Python对其检验：
					`P= (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)`
				</section>

				<section data-markdown>
					## 举例子
					```
					Python 3.4.0 (default, Mar 30 2014, 19:23:13)
					[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
					Type "help", "copyright", "credits" or "license" for more information. 
					>>>p=115792089237316195423570985008687907853269984665640564039457584007908834671663 
					>>>x=55066263022277343669578718895168534326250603453777594175500187360389116729240
					>>>y=32670510020758816978083085130507043184471273380659243275938904335757337482424 
					>>>(x**3+7-y**2)%p
					0
					```
				</section>

				<section data-markdown>
					## 椭圆曲线加密
					- 在椭圆曲线的数学原理中，有一个点被称为“无穷远点”，这大致对应于0在加法中的作用。
					- 计算机中，它有时表示为X = Y = 0（虽然这不满足椭圆曲线方程，但可作为特殊情况进行检验）。
					- 还有一个 + 运算符，被称为“加法”。
					- 给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3 = P1 + P2。
					- 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。
					- 这条直线恰好与椭圆曲线相交于另外一个地方。此点记为P3'= (x，y)。然后，在x轴做翻折获得P3=(x，-y)。
				</section>

				<section data-markdown>
					## 椭圆曲线加密
					- 下面是几个可以解释“无穷远点”之存在需要的特殊情况。
					- 若P1和P2是同一点，P1和P2间的连线则为点P1的切线。曲线上有且只有一个新的点与该切线相交。
					- 该切线的斜率可用微积分求得。即使限制曲线点为两个整数坐标也可求得斜率！
					- 在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3=“无穷远点”。
				</section>

				<section data-markdown>
					## 继续
					- 若P1就是“无穷远点”，那么其和P1+P2=P2。
					- 类似地，当P2是无穷远点，则P1+P2=P1。
					- 这就是把无穷远点类似于0的作用。
				</section>

				<section data-markdown>
					## 继续
					- 事实证明，在这里 + 运算符遵守结合律，这意味着(A+B)+C = A+(B+C)。
					- 这就是说我们可以直接不加括号书写 A + B + C，而不至于混淆。
					- 因此，我们已经定义了椭圆加法，我们可以对乘法用拓展加法的标准方法进行定义。
					- 给定椭圆曲线上的点P，如果k是整数，则 kP = P + P + P + … + P（k次）。注意，在这种情况下k有时被混淆而称为“指数”。
				</section>

				<section data-markdown>
					## 生成公钥
					- 以一个随机生成的私钥k为起点，我们将其与曲线上预定的生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。
					- 生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的：
					- `K=k*G`
				</section>

				<section data-markdown>
					## 继续
					- 其中k是私钥，G是生成点，在该曲线上所得的点K是公钥。
					- 因为所有比特币用户的生成点是相同的，一个私钥k乘以G将得到相同的公钥K。
					- k和K之间的关系是固定的，但只能单向运算，即从k得到K。这就是可以把比特币地址（K的衍生）与任何人共享而不会泄露私钥（k）的原因。
				</section>

				<section data-markdown>
					## 继续
					- 因为其中的数学运算是单向的，所以私钥可以转换为公钥，但公钥不能转换回私钥。
					- 为实现椭圆曲线乘法，我们以之前产生的私钥k和与生成点G相乘得到公钥K：
					- `K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G`
					- 公钥K被定义为一个点K=(x, y): 其中
					- `x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A`
					- `y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB`
				</section>

				<section data-markdown>
					## 继续
					- 为了展示整数点的乘法，我们将使用较为简单的实数范围的椭圆曲线。请记住，其中的数学原理是相同的。
					- 我们的目标是找到生成点G的倍数kG。也就是将G相加k次。
					- 在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后翻折到x轴。
				</section>

				<section data-markdown>
					## 下图显示了在曲线上得到G、2G、4G的几何操作
					(椭圆曲线乘法示意图)[./images/chengfa.png]
				</section>

				<section data-markdown>
					## 继续
					- 大多数比特币程序使用OpenSSL加密库进行椭圆曲线计算。例如，调用EC_POINT_mul()函数，可计算得到公钥。
				</section>

				<section data-markdown>
					## 比特币地址
					- 比特币地址是一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享。
					- 由公钥（一个同样由数字和字母组成的字符串）生成的比特币地址以数字“1”开头。
					- 例子: `1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy`
				</section>

				<section data-markdown>
					## 比特币地址
					- 在交易中，比特币地址通常以收款方出现。如果把比特币交易比作一张支票，比特币地址就是收款人，也就是我们要写入收款人一栏的内容。
					- 一张支票的收款人可能是某个银行账户，也可能是某个公司、机构，甚至是现金支票。
					- 支票不需要指定一个特定的账户，而是用一个抽象的名字作为收款人，这使它成为一种相当灵活的支付工具。
					- 与此类似，比特币地址使用类似的抽象，也使比特币交易变得很灵活。比特币地址可以代表一对公钥和私钥的所有者，也可以代表其它东西，比如付款脚本。
				</section>

				<section data-markdown>
					## 比特币地址
					- 比特币地址可由公钥经过单向的加密哈希算法得到。
					- 哈希算法是一种单向函数，接收任意长度的输入产生指纹或哈希。
					- 加密哈希函数在比特币中被广泛使用：比特币地址、脚本地址以及在挖矿中的工作量证明算法。
					- 由公钥生成比特币地址时使用的算法是SHA和RIPEMD，具体地说是SHA256和RIPEMD160。
				</section>

				<section data-markdown>
					## 比特币地址
					- 以公钥 K 为输入，计算其SHA256哈希值，并以此结果计算RIPEMD160哈希值，得到一个长度为160位（20字节）的数字：
					- A = RIPEMD160(SHA256(K))
					- 公式中，K是公钥，A是生成的比特币地址。
					- 比特币地址与公钥不同。比特币地址是由公钥经过单向的哈希函数生成的。
				</section>

				<section data-markdown>
					## 比特币地址
					- 通常用户见到的比特币地址是经过“Base58Check”编码的，这种编码使用了58个字符和校验码。
					- 提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。
					- Base58Check编码也被用于比特币的其它地方，例如比特币地址、私钥、加密的密钥和脚本哈希中，用来提高可读性和录入的正确性。
				</section>

				<section data-markdown>
					## 下图描述了如何从公钥生成比特币地址。
					(公钥生成比特币地址)[./images/dizhi.png]
				</section>

				<section data-markdown>
					## Base58和Base58Check编码
					- 为了更简洁方便地表示长串的数字，使用更少的符号，许多计算机系统会使用一种以数字和字母组成的大于十进制的表示法。
					- 例如，传统的十进制计数系统使用0-9十个数字，而十六进制系统使用了额外的A-F六个字母。
					- 一个同样的数字，它的十六进制表示就会比十进制表示更短。
					- Base64使用了26个小写字母、26个大写字母、10个数字以及两个符号（例 如“+”和“/”），用于在电子邮件这样的基于文本的媒介中传输二进制数据。
					- Base64通常用于编码邮件中的附件。
				</section>

				<section data-markdown>
					## Base58和Base58Check编码
					- Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。
					- 这种编码格式不仅实现了数据压缩，保持了易读性，还具有错误诊断功能。
					- Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错读和在特定字体中容易混淆的字符。
					- 具体地，Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“/”两个字符。
					- 简而言之，Base58就是由不包括（0，O，l，I）的大小写字母和数字组成。
				</section>

				<section data-markdown>
					## 比特币的Base58字母表
					`123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`
				</section>

				<section data-markdown>
					## 继续
					- 为了增加防止打印和转录错误的安全性，Base58Check是一种常用在比特币中的Base58编码格式，比特币有内置的检查错误的编码。
					- 检验和是添加到正在编码的数据末端的额外4个字节。
					- 校验和是从编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。
				</section>

				<section data-markdown>
					## 继续
					- 使用Base58check编码时，解码软件会计算数据的校验和并和编码中自带的校验和进行对比。
					- 二者不匹配则表明有错误产生，那么这个Base58Check的数据就是无效的。
					- 一个错误比特币地址就不会被钱包软件认为是有效的地址，否则这种错误会造成资金的丢失。
				</section>

				<section data-markdown>
					## 继续
					- 为了将数据（数字）转换成Base58Check格式，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来识别编码的数据的类型。
					- 例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。
				</section>

				<section data-markdown>
					## 继续
					(前缀)[./images/qianzhui.png]
				</section>

				<section data-markdown>
					## “双哈希”校验和
					- `checksum = SHA256(SHA256(prefix+data))`
					- 在产生的长32个字节的哈希值（两次哈希运算）中，我们只取前4个字节。这4个字节就作为检验错误的代码或者校验和。校验码会添加到数据之后。
					- 结果由三部分组成：前缀、数据和校验和。这个结果采用之前描述的Base58字母表编码。
				</section>

				<section data-markdown>
					## 编码过程示意图
					(编码过程示意图)[./images/bianmaguocheng.png]
				</section>

				<section data-markdown>
					## 继续
					- 在比特币中，大多数需要向用户展示的数据都使用Base58Check编码，可以实现数据压缩，易读而且有错误检验。
					- Base58Check编码中的版本前缀是用来创造易于辨别的格式，在Base58里的格式在Base58Check编码的有效载荷的开始包含了明确的属性。
					- 这些属性使用户可以轻松明确被编码的数据的类型以及如何使用它们。
					- 例如我们可以看到他们的不同，Base58Check编码的比特币地址是以1开头的，而Base58Check编码的私钥WIF是以5开头的。
				</section>

				<section data-markdown>
					## 继续
					- 我们回顾比特币地址产生的完整过程，从私钥、到公钥（椭圆曲线上某个点）、再到两次哈希的地址，到最终的Base58Check编码。
					- C++代码完整详细的展示了从私钥到Base58Check编码后的比特币地址的步骤。
					- 代码中使用libbitcoin library来实现某些辅助功能。
				</section>

				<section data-markdown>
					## 继续
					```cpp
					#include <bitcoin/bitcoin.hpp>

					int main()
					{
						// Private secret key string as base16
						bc::ec_secret decoded;
						bc::decode_base16(decoded,
							"038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776");
					
						bc::wallet::ec_private secret(
							decoded, bc::wallet::ec_private::mainnet_p2kh);
					
						// Get public key.
						bc::wallet::ec_public public_key(secret);
						std::cout << "Public key: " << public_key.encoded() << std::endl;
					
						// Create Bitcoin address.
						// Normally you can use:
						//    bc::wallet::payment_address payaddr =
						//        public_key.to_payment_address(
						//            bc::wallet::ec_public::mainnet_p2kh);
						//  const std::string address = payaddr.encoded();
					
						// Compute hash of public key for P2PKH address.
						bc::data_chunk public_key_data;
						public_key.to_data(public_key_data);
						const auto hash = bc::bitcoin_short_hash(public_key_data);
					
						bc::data_chunk unencoded_address;
						// Reserve 25 bytes
						//   [ version:1  ]
						//   [ hash:20    ]
						//   [ checksum:4 ]
						unencoded_address.reserve(25);
						// Version byte, 0 is normal BTC address (P2PKH).
						unencoded_address.push_back(0);
						// Hash data
						bc::extend_data(unencoded_address, hash);
						// Checksum is computed by hashing data, and adding 4 bytes from hash.
						bc::append_checksum(unencoded_address);
						// Finally we must encode the result in Bitcoin's base58 encoding.
						assert(unencoded_address.size() == 25);
						const std::string address = bc::encode_base58(unencoded_address);
					
						std::cout << "Address: " << address << std::endl;
						return 0;
					}
					```	
				</section>

				<section data-markdown>
					## 编译(代码使用预定义的私钥在每次运行时产生相同的比特币地址)
					```
					# Compile the addr.cpp code
					$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)
					# Run the addr executable
					$ ./addr
					Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK
					```
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
